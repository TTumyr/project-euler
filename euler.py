import math
def main():
    #euler_1(1000)
    #euler_2(4000000)
    #euler_3(600851475143)
    #euler_4(3)
    #euler_5(20)
    euler_6(100)


def euler_6(num):
    # The square of the sum of the first ten natural numbers is,
    # Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is .
    # Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
    num_range = [i for i in range(1, num+1)]
    sum_squares = 0
    sum_numbers_sq = 0
    for i in num_range:
        sum_squares += i ** 2
        sum_numbers_sq += i
    sum_numbers_sq = sum_numbers_sq ** 2
    print(f"The difference: {sum_numbers_sq - sum_squares}, sum squares: {sum_squares} sum numbers squared: {sum_numbers_sq}")


def euler_5(num):
    # 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
    # What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
    num_range = [i for i in range(2, num+1)]
    base = num
    while True:
        current_num = base
        for i in num_range:
            if base % i != 0:
                base += num # can never be less than the largest number
        if current_num == base: 
            print(f"Smallest number divisible by range 1 to {num} is {base}")
            return


def euler_4(num):
    #A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 Ã— 99.
    #Find the largest palindrome made from the product of two 3-digit numbers.
    max_num = 1 * (10 ** (num)) - 1
    max_num_limiter = 1 * (10 ** (num-1))
    digits = []
    result = 0
    highest_palindrome_ab = []
    highest_palindrome = 0
    cycles = 0
    for a in range(max_num, 0, -1):
        if highest_palindrome == 0 and a > max_num - max_num_limiter:
            for b in range(max_num, 0, -1):
                cycles += 1
                if highest_palindrome == 0 and b > max_num - max_num_limiter:
                    result = a * b
                    digits = [int(i) for i in str(result)]
                    for i in range(int(math.floor(len(digits)/2))):
                        if(digits[i] != digits[-(i+1)]):
                            result = 0
                    if result != 0:
                        if result > highest_palindrome:
                            highest_palindrome = result
                            highest_palindrome_ab.extend([a,b])
    print("highest palindrome: ", highest_palindrome, highest_palindrome_ab, "cycles: ", cycles)
        ## Not too happy with this solution as it is massively slow
        ## Shortened it by adding a logical limiter (can ofc be done in the range function directly), as it was 998001 cycles to solve for 3 digits.
                

def euler_3(num = 1):
    # The prime factors of 13195 are 5, 7, 13 and 29.
    # What is the largest prime factor of the number 600851475143 ?
        # testing a simple method first
    i = 2
    factors = []
    while i <= num:
        if(num % i == 0):
            factors.append(i)
            num = num / i
            i = 1
        i += 1
    print(factors[-1])
        # formula N = (c+d/2)^2 - (c-d/2)^2 Fermat's factorization method https://en.wikipedia.org/wiki/Fermat's_factorization_method
        # The trial is -- hoping a^2 - N = b^2
        # round up square root of N
        ## Very interesting method, the math is quite complicated, will have a deeper look into it
        # # round up square root of N
        # sqr_num = math.ceil(math.sqrt(num))
        # # formula b^2 = sqrt(num)^2 - num
        # rectangle = sqr_num ** 2 - num
        # sqr_num -= 1
        # while math.sqrt(rectangle) % 2 != 1:
        #     sqr_num += 1
        #     rectangle = sqr_num ** 2 - num
        # a = sqr_num
        # b = math.sqrt(rectangle)
        # # the correct values are produced from the while loop. The formula: a-b = N/(a+b)
        # # a = sqr_num, b = sqrt(rectangle)
        # aminb = a - b
        # aplusb = a + b 
        # print(aminb, aplusb)


def euler_2(max_num):
    # Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
    # 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
    #By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
    numbers = [1,2]
    even_nums = numbers[1:2]
    num = 0
    while num < max_num:
         num = numbers[-1] + numbers[-2]
         if num < max_num:
            numbers.append(num)
            if num % 2 == 0:
                even_nums.append(num)
    print(sum(even_nums))

def euler_1(max_num):
    # Multiples of 3 and 5  // 1
    # Find the sum of all the multiples of 3 or 5 below 1000.
    # Gives an error on 233168
    print(sum(num for num in range(max_num) if num % 3 == 0 or num % 5 == 0))

# useful math operations
def getDigit(num, i):
    return math.floor((math.abs/num) / math.pow(10, i)) % 10
def digitCount(num):
    return math.floor(math.log10(abs(num))) + 1
main()